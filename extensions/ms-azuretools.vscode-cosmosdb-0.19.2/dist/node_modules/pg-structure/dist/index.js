"use strict";
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
/* eslint-disable @typescript-eslint/no-explicit-any */
const pg_1 = require("pg");
const pg_connection_string_1 = require("pg-connection-string");
const helper_1 = require("./util/helper");
const db_1 = __importDefault(require("./pg-structure/db"));
const schema_1 = __importDefault(require("./pg-structure/schema"));
const domain_1 = __importDefault(require("./pg-structure/type/domain"));
const built_in_types_1 = __importDefault(require("./util/built-in-types"));
const enum_type_1 = __importDefault(require("./pg-structure/type/enum-type"));
const base_type_1 = __importDefault(require("./pg-structure/type/base-type"));
const composite_type_1 = __importDefault(require("./pg-structure/type/composite-type"));
const table_1 = __importDefault(require("./pg-structure/entity/table"));
const view_1 = __importDefault(require("./pg-structure/entity/view"));
const materialized_view_1 = __importDefault(require("./pg-structure/entity/materialized-view"));
const column_1 = __importDefault(require("./pg-structure/column"));
const pg_structure_1 = __importDefault(require("./pg-structure"));
const primary_key_1 = __importDefault(require("./pg-structure/constraint/primary-key"));
const unique_constraint_1 = __importDefault(require("./pg-structure/constraint/unique-constraint"));
const check_constraint_1 = __importDefault(require("./pg-structure/constraint/check-constraint"));
const exclusion_constraint_1 = __importDefault(require("./pg-structure/constraint/exclusion-constraint"));
const foreign_key_1 = __importDefault(require("./pg-structure/constraint/foreign-key"));
const types_1 = require("./types");
const range_type_1 = __importDefault(require("./pg-structure/type/range-type"));
var column_2 = require("./pg-structure/column");
exports.Column = column_2.default;
var db_2 = require("./pg-structure/db");
exports.Db = db_2.default;
var pg_structure_2 = require("./pg-structure");
exports.Index = pg_structure_2.default;
var schema_2 = require("./pg-structure/schema");
exports.Schema = schema_2.default;
var constraint_1 = require("./pg-structure/base/constraint");
exports.Constraint = constraint_1.default;
var db_object_1 = require("./pg-structure/base/db-object");
exports.DbObject = db_object_1.default;
var entity_1 = require("./pg-structure/base/entity");
exports.Entity = entity_1.default;
var relation_1 = require("./pg-structure/base/relation");
exports.Relation = relation_1.default;
var type_1 = require("./pg-structure/base/type");
exports.Type = type_1.default;
var check_constraint_2 = require("./pg-structure/constraint/check-constraint");
exports.CheckConstraint = check_constraint_2.default;
var exclusion_constraint_2 = require("./pg-structure/constraint/exclusion-constraint");
exports.ExclusionConstraint = exclusion_constraint_2.default;
var foreign_key_2 = require("./pg-structure/constraint/foreign-key");
exports.ForeignKey = foreign_key_2.default;
var primary_key_2 = require("./pg-structure/constraint/primary-key");
exports.PrimaryKey = primary_key_2.default;
var unique_constraint_2 = require("./pg-structure/constraint/unique-constraint");
exports.UniqueConstraint = unique_constraint_2.default;
var materialized_view_2 = require("./pg-structure/entity/materialized-view");
exports.MaterializedView = materialized_view_2.default;
var table_2 = require("./pg-structure/entity/table");
exports.Table = table_2.default;
var view_2 = require("./pg-structure/entity/view");
exports.View = view_2.default;
var m2m_relation_1 = require("./pg-structure/relation/m2m-relation");
exports.M2MRelation = m2m_relation_1.default;
var m2o_relation_1 = require("./pg-structure/relation/m2o-relation");
exports.M2ORelation = m2o_relation_1.default;
var o2m_relation_1 = require("./pg-structure/relation/o2m-relation");
exports.O2MRelation = o2m_relation_1.default;
var base_type_2 = require("./pg-structure/type/base-type");
exports.BaseType = base_type_2.default;
var built_in_type_1 = require("./pg-structure/type/built-in-type");
exports.BuiltInType = built_in_type_1.default;
var composite_type_2 = require("./pg-structure/type/composite-type");
exports.CompositeType = composite_type_2.default;
var domain_2 = require("./pg-structure/type/domain");
exports.Domain = domain_2.default;
var enum_type_2 = require("./pg-structure/type/enum-type");
exports.EnumType = enum_type_2.default;
var range_type_2 = require("./pg-structure/type/range-type");
exports.RangeType = range_type_2.default;
__export(require("./types/index"));
/**
 * Returns database name.
 *
 * @ignore
 * @param pgClientOrConfig is input to get database name from.
 * @returns database name.
 */
/* istanbul ignore next */
function getDatabaseName(pgClientOrConfig) {
    if (pgClientOrConfig instanceof pg_1.Client) {
        return "database";
    }
    return (typeof pgClientOrConfig === "string" ? pg_connection_string_1.parse(pgClientOrConfig).database : pgClientOrConfig.database) || "database";
}
/**
 * Returns list of schames in database. If no patterns are given returns all schemas except system schemas.
 * Patterns are feeded to `LIKE` operator of SQL, so `%` and `_` may be used.
 *
 * @ignore
 * @param client is pg client.
 * @param include is pattern to be used in SQL query `LIKE` part.
 * @param exclude is pattern to be used in SQL query `NOT LIKE` part.
 * @param system is whether to include system schemas in result.
 * @returns array of objects describing schemas.
 */
async function getSchemas(client, { include = [], exclude = [], system = false }) {
    const where = ["NOT pg_is_other_temp_schema(oid)", "nspname <> 'pg_toast'"];
    const whereInclude = [];
    const parameters = [];
    const includedPatterns = include.concat(system && include.length > 0 ? ["information_schema", "pg_%"] : []);
    const excludedPatterns = exclude.concat(system ? [] : ["information_schema", "pg_%"]);
    includedPatterns.forEach((pattern, i) => {
        whereInclude.push(`nspname LIKE $${i + 1}`); // nspname LIKE $1
        parameters.push(pattern);
    });
    if (whereInclude.length > 0)
        where.push(`(${whereInclude.join(" OR ")})`);
    excludedPatterns.forEach((pattern, i) => {
        where.push(`nspname NOT LIKE $${i + include.length + 1}`); // nspname NOT LIKE $2
        parameters.push(pattern);
    });
    const whereQuery = `WHERE ${where.join(" AND ")}`;
    const sql = `SELECT oid, nspname AS name, obj_description(oid, 'pg_namespace') AS comment FROM pg_namespace ${whereQuery} ORDER BY nspname`;
    const result = await client.query(sql, parameters);
    return result.rows;
}
/**
 * Adds schema instances to database.
 *
 * @ignore
 * @param db is Db object.
 */
function addSchemas(db, rows) {
    rows.forEach((row) => {
        db.schemas.push(new schema_1.default({ ...row, db }));
    });
}
/**
 * Adds types to database.
 *
 * @ignore
 * @param db  is DB object
 * @param rows are query result of types to be added.
 */
function addTypes(db, rows) {
    built_in_types_1.default(db._systemSchema).forEach((builtinType) => db._systemSchema.types.push(builtinType));
    const typeKinds = { d: domain_1.default, e: enum_type_1.default, b: base_type_1.default, c: composite_type_1.default, r: range_type_1.default };
    rows
        .filter((row) => row.kind in typeKinds)
        .forEach((row) => {
        const schema = db.schemas.get(row.schemaOid, { key: "oid" });
        const kind = row.kind;
        const type = new typeKinds[kind]({ ...row, schema, sqlType: row.sqlType });
        schema.types.push(type);
    });
}
/**
 * Adds entities to database.
 *
 * @ignore
 * @param db  is DB object
 * @param rows are query result of entities to be added.
 */
function addEntities(db, rows) {
    rows.forEach((row) => {
        const schema = db.schemas.get(row.schemaOid, { key: "oid" });
        /* istanbul ignore else */
        if (row.kind === "r") {
            schema.tables.push(new table_1.default({ ...row, schema }));
        }
        else if (row.kind === "v") {
            schema.views.push(new view_1.default({ ...row, schema }));
        }
        else if (row.kind === "m") {
            schema.materializedViews.push(new materialized_view_1.default({ ...row, schema }));
        }
    });
}
/**
 * Adds columns to database.
 *
 * @ignore
 * @param db  is DB object
 * @param rows are query result of columns to be added.
 */
function addColumns(db, rows) {
    rows.forEach((row) => {
        const parent = (row.parentKind === "c"
            ? db.types.get(row.parentOid, { key: "classOid" })
            : db.entities.get(row.parentOid, { key: "oid" }));
        parent.columns.push(new column_1.default({ parent, ...row }));
    });
}
/**
 * Adds indexes to database.
 *
 * @ignore
 * @param db  is DB object
 * @param rows are query result of indexes to be added.
 */
function addIndexes(db, rows) {
    rows.forEach((row) => {
        const table = db.tables.get(row.tableOid, { key: "oid" });
        const index = new pg_structure_1.default({ ...row, table });
        const indexExpressions = [...row.indexExpressions]; // Non column reference index expressions.
        row.columnPositions.forEach((position) => {
            // If position is 0, then it's an index attribute that is not simple column references. It is an expression which is stored in indexExpressions.
            const columnOrExpression = position > 0 ? table.columns[position - 1] : indexExpressions.shift();
            index.columnsAndExpressions.push(columnOrExpression);
        });
        table.indexes.push(index);
    });
}
/**
 * Adds constraints to database.
 *
 * @ignore
 * @param db  is DB object
 * @param rows are query result of constraints to be added.
 */
function addConstraints(db, rows) {
    const actionLetterMap = {
        a: "NO ACTION" /* NoAction */,
        r: "RESTRICT" /* Restrict */,
        c: "CASCADE" /* Cascade */,
        n: "SET NULL" /* SetNull */,
        d: "SET DEFAULT" /* SetDefault */,
    };
    const matchTypeLetterMap = {
        f: types_1.MatchType.Full,
        p: types_1.MatchType.Partial,
        s: types_1.MatchType.Simple,
    };
    rows.forEach((row) => {
        const table = db.tables.getMaybe(row.tableOid, { key: "oid" });
        const index = db.indexes.getMaybe(row.indexOid, { key: "oid" });
        const domain = db.types.getMaybe(row.typeOid, { key: "oid" });
        /* istanbul ignore else */
        if (table) {
            /* istanbul ignore else */
            if (row.kind === "p") {
                table.constraints.push(new primary_key_1.default({ ...row, index, table }));
            }
            else if (row.kind === "u") {
                table.constraints.push(new unique_constraint_1.default({ ...row, index, table }));
            }
            else if (row.kind === "x") {
                table.constraints.push(new exclusion_constraint_1.default({ ...row, index, table }));
            }
            else if (row.kind === "c") {
                table.constraints.push(new check_constraint_1.default({ ...row, table, expression: row.checkConstraintExpression }));
            }
            else if (row.kind === "f") {
                const foreignKey = new foreign_key_1.default({
                    ...row,
                    table,
                    index,
                    columns: row.constrainedColumnPositions.map((pos) => table.columns.get(pos, { key: "attributeNumber" })),
                    onUpdate: actionLetterMap[row.onUpdate],
                    onDelete: actionLetterMap[row.onDelete],
                    matchType: matchTypeLetterMap[row.matchType],
                });
                table.constraints.push(foreignKey);
                foreignKey.referencedTable.foreignKeysToThis.push(foreignKey);
            }
        }
        else if (domain) {
            /* istanbul ignore else */
            if (row.kind === "c") {
                domain.checkConstraints.push(new check_constraint_1.default({ ...row, domain, expression: row.checkConstraintExpression }));
            }
        }
    });
}
/**
 * Returns results of SQL queries of meta data.
 *
 * @ignore
 */
async function getQueryResultsFromDb(client, includeSchemasArray, excludeSchemasArray, includeSystemSchemas) {
    const schemaRows = await getSchemas(client, { include: includeSchemasArray, exclude: excludeSchemasArray, system: includeSystemSchemas });
    const schemaOids = schemaRows.map((schema) => schema.oid);
    return Promise.all([
        schemaRows,
        helper_1.executeSqlFile("type.sql", client, schemaOids),
        helper_1.executeSqlFile("entity.sql", client, schemaOids),
        helper_1.executeSqlFile("column.sql", client, schemaOids),
        helper_1.executeSqlFile("index.sql", client, schemaOids),
        helper_1.executeSqlFile("constraint.sql", client, schemaOids),
    ]);
}
// function getMetaDataFromJson(data: any): A {}
/**
 * Creates and returns [[Db]] object which represents given database's structure. It is possible to include or exclude some schemas
 * using options. Please note that if included schemas contain references (i.e. foreign key to other schema or type in other schema)
 * to non-included schema, throws exception.
 *
 * @param pgClientOrConfig is connection string or [node-postgres client](https://node-postgres.com/api/client) or [node-postgres client](https://node-postgres.com/api/client) configuration.
 * @param name is name of the database. This is inferred if possible from client or connection string.
 * @param commentDataToken is tag name to extract JSON data from from database object's comments. For example by default JSON data between `[pg-structure][/pg-structure]` is available imn database objects. Data can be retrieved with {@link DbObject.commentData commentData} method.
 * @param includeSchemas is pattern similar to `SQL LIKE` (i.e `public_%`) or list of schemas to include.
 * @param excludeSchemas is pattern similar to `SQL LIKE` (i.e `public_%`) or list of schemas to exclude.
 * @param includeSystemSchemas is whether to include PostgreSQL system schemas (i.e. `pg_catalog`) from database.
 * @param foreignKeyAliasSeparator is character to separate {@link ForeignKey.sourceAlias source alias} and {@link ForeignKey.targetAlias target alias} in {@link ForeignKey foreign key} name. For example: `prime_color,product`.
 * @param foreignKeyAliasTargetFirst is whether first part of the foreign key aliases contains target alias (i.e `company_employees`) or source alias (i.e. `employee_company`).
 * @param relationNameFunctions Optional functions to generate names for relationships. If not provided, default naming functions are used. All necessary information such as {@link Table table} names, {@link Column columns}, {@link ForeignKey foreign key}, {@link DbObject.commentData comment data} can be accessed via passed {@link Relation relation} parameter. It is also possible to use one of the builtin naming functions such as `short`, `descriptive`.
 * @returns [[Db]] object which represents given database's structure.
 */
async function pgStructure(pgClientOrConfig, { name, commentDataToken = "pg-structure", includeSchemas, excludeSchemas, includeSystemSchemas, foreignKeyAliasSeparator = ",", foreignKeyAliasTargetFirst = false, relationNameFunctions = "short", keepConnection = false, } = {}) {
    const { client, closeConnectionAfter } = await helper_1.getPgClient(pgClientOrConfig);
    const includeSchemasArray = Array.isArray(includeSchemas) || includeSchemas === undefined ? includeSchemas : [includeSchemas];
    const excludeSchemasArray = Array.isArray(excludeSchemas) || excludeSchemas === undefined ? excludeSchemas : [excludeSchemas];
    const queryResults = await getQueryResultsFromDb(client, includeSchemasArray, excludeSchemasArray, includeSystemSchemas);
    const [schemaRows, typeRows, tableRows, columnRows, indexRows, constraintRows] = queryResults;
    const db = new db_1.default(name || getDatabaseName(pgClientOrConfig), {
        commentDataToken,
        relationNameFunctions,
        foreignKeyAliasSeparator,
        foreignKeyAliasTargetFirst,
    }, queryResults);
    addSchemas(db, schemaRows);
    addTypes(db, typeRows);
    addEntities(db, tableRows);
    addColumns(db, columnRows);
    addIndexes(db, indexRows);
    addConstraints(db, constraintRows);
    if (!keepConnection && closeConnectionAfter)
        client.end(); // If a connected client is provided, do not close connection.
    return db;
}
exports.default = pgStructure;
/**
 * Deserializes given data to create [[Db]] object.
 *
 * @param serializedData is serialized data of the `Db` object.
 * @returns [[Db]] object for given serialized data.
 * @example
 * import pgStructure, { deserialize } from "pg-structure";
 * const db = await pgStructure({ database: "db", user: "u", password: "pass" });
 * const serialized = db.serialize();
 * const otherDb = deserialize(serialized);
 */
function deserialize(serializedData) {
    const data = JSON.parse(serializedData);
    const db = new db_1.default(data.name, data.config, data.queryResults);
    const [schemaRows, typeRows, tableRows, columnRows, indexRows, constraintRows] = data.queryResults;
    addSchemas(db, schemaRows);
    addTypes(db, typeRows);
    addEntities(db, tableRows);
    addColumns(db, columnRows);
    addIndexes(db, indexRows);
    addConstraints(db, constraintRows);
    return db;
}
exports.deserialize = deserialize;
//# sourceMappingURL=index.js.map